name: End-to-End LLMOps Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_IMAGE: hueilau33/llm-ops-workshop3
  REGISTRY: docker.io

jobs:
  # Job 1: Unit Tests and Quality Checks
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.9
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run unit tests
      run: |
        python -m pytest test_main.py -v --tb=short

    - name: Install Node.js for Promptfoo
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install Promptfoo
      run: |
        npm install -g promptfoo@latest

    - name: Start FastAPI service for testing
      run: |
        python main.py &
        sleep 15
        # Wait for service to be ready
        for i in {1..30}; do
          if curl -s http://localhost:8000/health > /dev/null 2>&1; then
            echo "FastAPI service is ready!"
            break
          fi
          echo "Waiting for service... ($i/30)"
          sleep 2
        done
        curl -f http://localhost:8000/health || exit 1
      timeout-minutes: 3

    - name: Run Promptfoo hallucination and bias tests
      run: |
        # Test a simple prompt first
        curl -X POST "http://localhost:8000/chat" \
          -H "Content-Type: application/json" \
          -d '{"question": "What is FastAPI?", "context": "FastAPI is a web framework for Python"}' || echo "API test failed"
        
        # Run Promptfoo evaluation with simplified config
        promptfoo eval -c promptfoo-simple.yaml --output promptfoo-results.json || echo "Promptfoo tests completed with issues"
      timeout-minutes: 5

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          promptfoo-results.json
          pytest-report.xml

  # Job 2: Build and Push Docker Image
  build-and-push:
    runs-on: ubuntu-latest
    needs: test
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Job 3: Security Scan with Trivy
  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      security-events: write
      actions: read
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4



    - name: Run Trivy filesystem scan
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-fs-results.sarif'
        trivy-config: 'trivy.yaml'

    - name: Upload Trivy filesystem scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-fs-results.sarif'

    - name: Run Trivy filesystem scan (Table format)
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'table'
        severity: 'CRITICAL,HIGH,MEDIUM'
        trivy-config: 'trivy.yaml'



    - name: Run Trivy configuration scan
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'config'
        scan-ref: '.'
        format: 'table'
        severity: 'CRITICAL,HIGH,MEDIUM'
        trivy-config: 'trivy.yaml'

    - name: Run Trivy secret scan
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        scanners: 'secret'
        format: 'table'
        severity: 'CRITICAL,HIGH,MEDIUM'
        trivy-config: 'trivy.yaml'

    - name: Upload security scan artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: trivy-security-reports
        path: |
          trivy-fs-results.sarif

  # Job 4: Deploy to Kubernetes
  deploy:
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update Kubernetes manifests
      run: |
        # Use a simple image reference for deployment
        DEPLOY_IMAGE="${{ env.DOCKER_IMAGE }}:${{ github.sha }}"
        echo "Using deployment image: $DEPLOY_IMAGE"
        
        # Update the image tag in deployment.yml
        sed -i "s|image: image_name|image: $DEPLOY_IMAGE|g" deployment.yml
        echo "Updated deployment.yml:"
        cat deployment.yml

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Check for Kubernetes configuration
      id: k8s-check
      run: |
        if [ -z "${{ secrets.KUBECONFIG }}" ]; then
          echo "No KUBECONFIG secret found. Skipping Kubernetes deployment."
          echo "To enable Kubernetes deployment, add KUBECONFIG secret to repository."
          echo "has-kubeconfig=false" >> $GITHUB_OUTPUT
        else
          echo "KUBECONFIG found. Proceeding with deployment."
          echo "has-kubeconfig=true" >> $GITHUB_OUTPUT
        fi

    - name: Configure kubectl
      if: steps.k8s-check.outputs.has-kubeconfig == 'true'
      run: |
        # Decode and set up kubeconfig
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        echo "KUBECONFIG=kubeconfig" >> $GITHUB_ENV

    - name: Test cluster connectivity
      if: steps.k8s-check.outputs.has-kubeconfig == 'true'
      run: |
        export KUBECONFIG=kubeconfig
        # Test if we can connect to the cluster
        if ! kubectl cluster-info >/dev/null 2>&1; then
          echo "❌ Unable to connect to Kubernetes cluster"
          echo "Please check your KUBECONFIG secret and cluster status"
          exit 1
        fi
        echo "✅ Successfully connected to Kubernetes cluster"
        kubectl version --short

    - name: Deploy to Kubernetes
      if: steps.k8s-check.outputs.has-kubeconfig == 'true'
      run: |
        export KUBECONFIG=kubeconfig
        echo "🚀 Deploying to Kubernetes..."
        
        kubectl apply -f deployment.yml
        kubectl apply -f service.yml
        
        echo "📊 Checking rollout status..."
        kubectl rollout status deployment/gpt-huggingface --timeout=300s
        
        echo "🔍 Getting service information..."
        kubectl get services gpt-hf-service
        
        echo "✅ Deployment completed successfully"

    - name: Skip deployment notice
      if: steps.k8s-check.outputs.has-kubeconfig == 'false'
      run: |
        echo "🔄 Kubernetes deployment was skipped"
        echo ""
        echo "To enable Kubernetes deployment:"
        echo "1. Set up a Kubernetes cluster"
        echo "2. Add KUBECONFIG as a repository secret (base64 encoded)"
        echo "3. Re-run the pipeline"
        echo ""
        echo "📦 Docker image was built and pushed successfully"
        echo "🛡️  Security scans completed"
        echo "✅ Pipeline completed without deployment"

    - name: Cleanup
      if: always()
      run: |
        rm -f kubeconfig

  # Job 5: Post-deployment validation
  validate:
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check if deployment was successful
      id: deploy-check
      run: |
        if [ -z "${{ secrets.KUBECONFIG }}" ]; then
          echo "No KUBECONFIG found. Skipping validation."
          echo "has-deployment=false" >> $GITHUB_OUTPUT
        else
          echo "KUBECONFIG found. Proceeding with validation."
          echo "has-deployment=true" >> $GITHUB_OUTPUT
        fi

    - name: Wait for deployment
      if: steps.deploy-check.outputs.has-deployment == 'true'
      run: sleep 30

    - name: Install Node.js for Promptfoo
      if: steps.deploy-check.outputs.has-deployment == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install Promptfoo
      if: steps.deploy-check.outputs.has-deployment == 'true'
      run: npm install -g promptfoo@latest

    - name: Configure kubectl
      if: steps.deploy-check.outputs.has-deployment == 'true'
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Get service endpoint
      if: steps.deploy-check.outputs.has-deployment == 'true'
      run: |
        export KUBECONFIG=kubeconfig
        # Get the NodePort service endpoint
        NODE_PORT=$(kubectl get service gpt-hf-service -o jsonpath='{.spec.ports[0].nodePort}')
        # For cloud environments, you might need to get the external IP
        # SERVICE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
        # For local testing, use localhost or cluster IP
        SERVICE_IP="localhost"
        echo "SERVICE_ENDPOINT=http://${SERVICE_IP}:${NODE_PORT}" >> $GITHUB_ENV

    - name: Health check
      if: steps.deploy-check.outputs.has-deployment == 'true'
      run: |
        echo "Testing endpoint: $SERVICE_ENDPOINT"
        curl -f $SERVICE_ENDPOINT/health || exit 1
        echo "✅ Health check passed"

    - name: Run production Promptfoo tests
      if: steps.deploy-check.outputs.has-deployment == 'true'
      run: |
        # Update promptfoo config to use deployed service
        sed -i "s|http://localhost:8000|$SERVICE_ENDPOINT|g" promptfoo-simple.yaml
        
        # Run subset of critical tests in production
        promptfoo eval -c promptfoo-simple.yaml --output production-promptfoo-results.json
        
        echo "🧪 Production AI safety tests completed"

    - name: Upload production test results
      if: steps.deploy-check.outputs.has-deployment == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: production-test-results
        path: production-promptfoo-results.json

    - name: Skip validation notice
      if: steps.deploy-check.outputs.has-deployment == 'false'
      run: |
        echo "🔄 Post-deployment validation was skipped"
        echo ""
        echo "Reason: No Kubernetes cluster configured"
        echo ""
        echo "✅ Pipeline completed successfully:"
        echo "  📋 Unit tests passed"
        echo "  🧪 AI safety tests completed"
        echo "  📦 Docker image built and pushed"
        echo "  🛡️  Security scans completed"
        echo ""
        echo "To enable deployment and validation:"
        echo "1. Set up a Kubernetes cluster"
        echo "2. Add KUBECONFIG as a repository secret"
        echo "3. Re-run the pipeline"

    - name: Cleanup
      if: always()
      run: rm -f kubeconfig